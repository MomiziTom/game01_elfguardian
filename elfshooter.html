<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>elfshooter</title>
		<script>
			let canvasW = 800;
			let canvasH = 600;
			let fps = setInterval(gameloop,(1/30)*1000);
			const gravity = 2;
			const arrowimgW = 98;
			const arrowimgH = 98;

			let testangle=0;
			let testU;
			let testV;
		
			function angleCorrect(ang){
				if((ang * 180/Math.PI)>= 175 && (ang * 180/Math.PI)<=180){
					ang -=(355 * Math.PI/180);
				}
				return ang;
			}

			// 座標クラス
			class Point {
				constructor (_x, _y) {
					this.x = _x;
					this.y = _y;
				}

				// 引数の位置へ向かうベクトルを求める
				getVecPoint(p) {
					return new Vec(p.x - this.x, p.y - this.y);
				}

				//数値を再設定
				setPoint (_x, _y) {
					this.x = _x;
					this.y = _y;
				}

			}

			// ベクトルクラス
			class Vec{
				constructor (_x, _y) {
					this.x = _x;
					this.y = _y;
				}

				// ベクトル同士の内積を求める
				dotVec(v) {
					return this.x * v.x + this.y * v.y;
				}

				// ベクトル同士の外積を求める
				crossVec(v) {
					return this.x * v.y - this.y * v.x;
				}

				// ベクトルの長さを求める
				getLength() {
					return Math.sqrt(this.x*this.x + this.y*this.y);
				}

				//数値を再設定
				setVec (_x, _y) {
					this.x = _x;
					this.y = _y;
				}

				// Y軸方向に重力を加算
				plusGravity(){
					this.y += gravity;
				}

			}

			// 線分クラス
			class Line {
				constructor (_start_p, _end_p) {
					this.start_p = _start_p;
					this.end_p = _end_p;
					// ベクトルを設定
					this.v = new Vec(
						this.end_p.x - this.start_p.x,
						this.end_p.y - this.start_p.y
					);
				}

				//数値を再設定
				setLine (_start_p, _end_p) {
					this.start_p = _start_p;
					this.end_p = _end_p;
					// ベクトルを設定
					this.v = new Vec(
						this.end_p.x - this.start_p.x,
						this.end_p.y - this.start_p.y
					);
				}

				//ベクトルの角度を求める
				getAngle(){
					return Math.atan2(this.v.y,this.v.x);
				}

				// 現在の始点を現在の終点で更新
				startToEnd(){
					this.start_p = new Point(this.end_p.x,this.end_p.y);
				}

				// 終点を引数ベクトル分移動
				moveEnd(v){
					this.end_p.x += v.x;
					this.end_p.y += v.y;
					this.v.x = this.end_p.x - this.start_p.x;
					this.v.y = this.end_p.y - this.start_p.y;
				}

			}

			// 円クラス
			class Circle {
				constructor (_p, _r) {
					this.p = _p;
					this.r = _r;
				}
			}

			// 円と線分の衝突判定処理
			// return true:衝突している false:衝突していない
			function circleColLine(circleP, lineAB) {
 
				let vecAP = lineAB.start_p.getVecPoint(circleP.p);
				let vecBP = lineAB.end_p.getVecPoint(circleP.p);

				// 線分AX、PXの長さを求める
				let dotAX = lineAB.v.dotVec(vecAP) / lineAB.v.getLength();
				let crossPX = lineAB.v.crossVec(vecAP) / lineAB.v.getLength();

				// 基本は線分PXの長さを設定
				let distance = Math.abs(crossPX);
				if (dotAX < 0) {
					// 例外１：線分AXと逆方向に最短座標がある場合 -> 線分APの長さを設定
					distance = vecAP.getLength();
				} else if (dotAX > lineAB.v.getLength()) {
					// 例外２：線分ABよりも先に最短座標がある場合 -> 線分BPの長さを設定
					distance = vecBP.getLength();
				}
				// ④ 最短距離が円の半径より小さければ衝突と判定
				return distance < circleP.r;
			}

			// 矢クラス
			class arrow{
				constructor(){
					this.speed = new Vec(0,0);
					this.shotornot = false;
					this.curP = new Point(0,0);
					this.preP = new Point(0,0);
					this.trajectoryLine = new Line(this.preP,this.preP);

				}
				shoot(p,op,pow){
					this.curP = new Point(op.x,op.y);
					this.preP = new Point(op.x,op.y);
					this.angle = Math.atan2((p.y - op.y),(p.x - op.x));
					this.speed.setVec((pow * Math.cos(this.angle)),(pow * Math.sin(this.angle)));
					this.trajectoryLine = new Line(this.preP,this.preP);
					let UVangle = angleCorrect(this.angle);
					this.imgangleU = Math.floor((UVangle * 180/Math.PI + 185)/10%9);
					this.imgangleV = Math.floor((UVangle * 180/Math.PI + 185)/90);
					this.shotornot = true;

				}
				move(){
					if(this.shotornot == true){
						this.trajectoryLine.startToEnd();
						this.trajectoryLine.moveEnd(this.speed);
						this.speed.plusGravity();
						this.angle = this.trajectoryLine.getAngle();//マイナスラジアンで上向き。右方向水平で0ラジアン。プラスラジアンで下向き。左方向水平でπ(3.1415...)
						let UVangle = angleCorrect(this.angle);
						this.imgangleU = Math.floor((UVangle * 180/Math.PI + 185)/10%9);
						this.imgangleV = Math.floor((UVangle * 180/Math.PI + 185)/90);
					}
				}
			}

			// 円形当たり判定敵クラス
			class enemyCircle{
				constructor(_p,_r){
					this.circle = new Circle(_p,_r);
					this.hit = false;
				}
				display(ctx){
					ctx.strokeStyle = "#000000";
					ctx.globalAlpha = 0.4;    //照準表示の不透明度
					ctx.lineWidth = this.circle.r*2;  //照準表示の大きさ
					ctx.lineCap = "round";
					ctx.beginPath();
					ctx.moveTo(this.circle.p.x,this.circle.p.y);
					ctx.lineTo(this.circle.p.x,this.circle.p.y);
					ctx.stroke();

				}
			}

			let mouseP = new Point(0,0);		//マウス位置
			let archerP = new Point(80,500);	//射手位置
			let alpha = 0.3;
			let aimCircle = 30;
			let clicknow = false;
			let shootnow = false;
			let charge = 0;
			let chargevalue = 0;
			let shot1 = new arrow();
			let shot2 = new arrow();
			let shot3 = new arrow();
			let shot4 = new arrow();
			let shot5 = new arrow();
			let enemy1 = new enemyCircle((new Point(400,400)),30);

			// ゲームループ
			function gameloop(){

				//数値計算領域----------------------------------------------------------<

				//操作受付----------<

				document.getElementById("field").addEventListener(
					"mousemove",
					function(event){
						mouseP.setPoint(event.offsetX,event.offsetY);
					}
				);
				document.getElementById("field").addEventListener(
					"mousedown",
					function(){
						clicknow = true;
					}
				);
				document.getElementById("field").addEventListener(
					"mouseup",
					function(){
						clicknow = false;
						shootnow = true;
					}
				);

				//操作受付---------->

				//計算部----------<

				if(clicknow == true){
					++chargevalue;
					charge = chargevalue * chargevalue * 0.3;
					if(charge >= 300){
						charge = 300;
					}

					//照準の不透明度、大きさの変化<
					alpha = charge/400;
					aimCircle = charge/10;
					//照準の不透明度、大きさの変化>
				}
				if(shootnow == true){

					if(shot4.shotornot == true){
						if(shot5.shotornot ==false){
							shot5.shoot(mouseP,archerP,charge);
						}
					}
					if(shot3.shotornot == true){
						if(shot4.shotornot ==false){
							shot4.shoot(mouseP,archerP,charge);
						}
					}
					if(shot2.shotornot == true){
						if(shot3.shotornot ==false){
							shot3.shoot(mouseP,archerP,charge);
						}
					}
					if(shot1.shotornot == true){
						if(shot2.shotornot ==false){
							shot2.shoot(mouseP,archerP,charge);
						}
					}
					if(shot1.shotornot == false){
						shot1.shoot(mouseP,archerP,charge);
					}
					charge = 0;
					chargevalue = 0;
					alpha = 0.3;
					aimCircle = 30;

					shootnow= false;
				}

				shot1.move();
				shot2.move();
				shot3.move();
				shot4.move();
				shot5.move();

				//計算部---------->

				//数値計算領域---------------------------------------------------------->



				//描画領域----------------------------------------------------------<

				let field = document.getElementById("field");
				field.width = canvasW;
				field.height = canvasH;
				let ctx = field.getContext("2d");
				ctx.imageSmoothingEnabled = false ;	//アンチエイリアスをオフ


				ctx.clearRect(0,0,canvasW,canvasH);	//描画領域クリア

				testangle = Math.atan2((mouseP.y - archerP.y),(mouseP.x - archerP.x));
				testangle = angleCorrect(testangle);
				testU = Math.floor((testangle * 180/Math.PI + 185)/10%9);
				testV = Math.floor((testangle * 180/Math.PI + 185)/90);
				ctx.drawImage(arrowimg,testU*48,testV*48,47,47,archerP.x-arrowimgW/2,archerP.y-arrowimgH/2,arrowimgW,arrowimgH);

				if(shot1.shotornot == true){
					let arrowimg = document.getElementById("arrowimg");
					let imgX = arrowimg.width;
					let imgY = arrowimg.height;
					ctx.drawImage(arrowimg,shot1.imgangleU*48,shot1.imgangleV*48,47,47,shot1.trajectoryLine.end_p.x-arrowimgH/2,shot1.trajectoryLine.end_p.y-arrowimgH/2,arrowimgW,arrowimgH);
				}
				if(shot2.shotornot == true){
					let arrowimg = document.getElementById("arrowimg");
					let imgX = arrowimg.width;
					let imgY = arrowimg.height;
					ctx.drawImage(arrowimg,shot2.imgangleU*48,shot2.imgangleV*48,47,47,shot2.trajectoryLine.end_p.x-arrowimgH/2,shot2.trajectoryLine.end_p.y-arrowimgH/2,arrowimgW,arrowimgH);
				}
				if(shot3.shotornot == true){
					let arrowimg = document.getElementById("arrowimg");
					let imgX = arrowimg.width;
					let imgY = arrowimg.height;
					ctx.drawImage(arrowimg,shot3.imgangleU*48,shot3.imgangleV*48,47,47,shot3.trajectoryLine.end_p.x-arrowimgH/2,shot3.trajectoryLine.end_p.y-arrowimgH/2,arrowimgW,arrowimgH);
				}
				if(shot4.shotornot == true){
					let arrowimg = document.getElementById("arrowimg");
					let imgX = arrowimg.width;
					let imgY = arrowimg.height;
					ctx.drawImage(arrowimg,shot4.imgangleU*48,shot4.imgangleV*48,47,47,shot4.trajectoryLine.end_p.x-arrowimgH/2,shot4.trajectoryLine.end_p.y-arrowimgH/2,arrowimgW,arrowimgH);
				}
				if(shot5.shotornot == true){
					let arrowimg = document.getElementById("arrowimg");
					let imgX = arrowimg.width;
					let imgY = arrowimg.height;
					ctx.drawImage(arrowimg,shot5.imgangleU*48,shot5.imgangleV*48,47,47,shot5.trajectoryLine.end_p.x-arrowimgH/2,shot5.trajectoryLine.end_p.y-arrowimgH/2,arrowimgW,arrowimgH);
				}

				if(circleColLine(enemy1.circle,shot1.trajectoryLine)){
					enemy1.display(ctx);
				}
				if(circleColLine(enemy1.circle,shot2.trajectoryLine)){
					enemy1.display(ctx);
				}
				if(circleColLine(enemy1.circle,shot3.trajectoryLine)){
					enemy1.display(ctx);
				}
				if(circleColLine(enemy1.circle,shot4.trajectoryLine)){
					enemy1.display(ctx);
				}
				if(circleColLine(enemy1.circle,shot5.trajectoryLine)){
					enemy1.display(ctx);
				}
				enemy1.display(ctx);

				//照準表示描画<
				ctx.strokeStyle = "#000000";
				ctx.globalAlpha = alpha;    //照準表示の不透明度
				ctx.lineWidth = aimCircle;  //照準表示の大きさ
				ctx.lineCap = "round";
				ctx.beginPath();
				ctx.moveTo(mouseP.x,mouseP.y);
				ctx.lineTo(mouseP.x,mouseP.y);
				ctx.stroke();
				//照準表示描画>

				//描画領域---------------------------------------------------------->

				document.getElementById("spantag").textContent = (`${mouseP.x}  ${mouseP.y}  ${testU}  ${testV}  ${testangle}`);
			}


		</script>
	</head>

	<body>
		<canvas id="field" width="1800" height="480"></canvas>
		<span id="spantag"></span>
		<img src="主人公シャラライメージ.png" style="display: none;">
		<img class="dotpic" id="arrowimg" src="arrow.png" style="display: none;">

	</body>
</html>

<!--キャラクター名
	主人公　：　シャララ
	主人公の妹　：　ルーヤ
	--> 